# GitHub Copilot Code Generation Instructions

## 0. Context & Ground Rules

This repo already contains a **mostly complete implementation** of Talk-To-My-Lawyer:

- Next.js App Router (TypeScript, SSR, Server Actions)
- Supabase (Auth, PostgreSQL, RLS)
- Stripe (subscriptions + letter allowances)
- AI letter generation
- Free trial system
- Employee coupons + commission tracking
- Secure admin portal at `/secure-admin-gateway`

**CRITICAL: Do not rebuild the app or create new architecture.**

This is an **extension-only** project. See "WORKING WITH THIS CODEBASE" section (bottom of this document) for detailed guidance on what this means.

---

## Quick Reference

**When adding new code:**

- ✅ Auth check: `import { createClient } from "@/lib/supabase/server"`
- ✅ Admin routes: Under `/secure-admin-gateway/*` only
- ✅ Database changes: New migration in `supabase/migrations/`
- ✅ AI calls: Via Vercel AI SDK in Next.js API routes (OpenAI GPT-4)
- ✅ Audit logging: `supabase.rpc('log_letter_audit', { ... })`
- ❌ Never: Call AI models outside of designated API routes
- ❌ Never: Expose OpenAI API key to client-side code
- ❌ Never: Routes under `/dashboard/admin` (legacy, blocked)
- ❌ Never: Multiple admin users (single admin only)

**Common patterns:**

```typescript
// Check letter allowance
const { data } = await supabase.rpc('check_letter_allowance', { u_id: userId })

// Admin authorization (correct)
WHERE role = 'admin'  // ✅ Correct

// NOT this (is_super_user is a business flag, not admin role)
WHERE is_super_user = true  // ❌ Wrong for admin checks
```

---

## 1) Tech Stack (As Implemented)

### Core

- **Next.js** (App Router, `app/` directory – see `package.json` for exact versions)
- **React + TypeScript**
- **Tailwind CSS + shadcn/ui** for UI components
- **Supabase**
  - Auth: email/password signups and logins
  - Database: PostgreSQL with migrations in `supabase/migrations/*.sql`
  - RLS policies and Postgres functions for business logic
- **Stripe**
  - Checkout sessions
  - Webhook/verification via `app/api/verify-payment/route.ts`

### AI Provider – Current State

- **AI Model:** OpenAI GPT-4 Turbo via Vercel AI SDK
- **Implementation:** Direct integration in Next.js API routes
- **Files:**
  - `app/api/generate-letter/route.ts` - Letter generation
  - `app/api/letters/[id]/improve/route.ts` - Letter improvement

**Architecture:**
- AI generation happens in Next.js API routes (server-side only)
- Uses Vercel AI SDK (`@ai-sdk/openai` and `ai` packages)
- OpenAI API key stored securely in Next.js environment variables
- Type-safe, excellent DX, built-in streaming support
- Single deployment pipeline (all in Next.js)

---

## 2) Key Files & Folder Map

Copilot should assume this as the **source of truth**:

### App Routes

- Public & Auth:
  - `app/page.tsx` – marketing/landing
  - `app/auth/login/page.tsx`
  - `app/auth/signup/page.tsx` (subscriber/employee flows)

- Subscriber / Employee:
  - `app/dashboard/page.tsx` – role-based router for logged-in users
  - `app/dashboard/letters/page.tsx` – subscriber "My Letters" list
  - `app/dashboard/letters/new/page.tsx` – letter intake + submit form
  - `app/dashboard/letters/[id]/page.tsx` – single letter detail for subscriber
  - `app/dashboard/subscription/page.tsx` – subscription status & plans
  - `app/dashboard/commissions/page.tsx` – **employee** commissions overview
  - `app/dashboard/coupons/page.tsx` – **employee** coupon codes

- Legacy admin (do **not** extend):
  - `app/dashboard/admin/**` – **legacy admin views**, now blocked by middleware

- Secure admin portal (primary admin surface – **use this**):
  - `app/secure-admin-gateway/login/page.tsx` – dual-auth login (email/password + portal key)
  - `app/secure-admin-gateway/dashboard/page.tsx` – main admin dashboard (Review Queue, metrics)
  - `app/secure-admin-gateway/dashboard/letters/page.tsx` – admin Review Center
  - `app/secure-admin-gateway/dashboard/all-letters/page.tsx` – all letters
  - `app/secure-admin-gateway/dashboard/users/page.tsx` – all profiles
  - `app/secure-admin-gateway/dashboard/commissions/page.tsx` – commission overview
  - `app/secure-admin-gateway/dashboard/analytics/page.tsx` – analytics

### API Routes

- AI & letters:
  - `app/api/generate-letter/route.ts`
  - `app/api/letters/[id]/improve/route.ts`
  - `app/api/letters/[id]/approve/route.ts`
  - `app/api/letters/[id]/reject/route.ts`
  - `app/api/letters/[id]/start-review/route.ts`
  - `app/api/letters/[id]/submit/route.ts`
  - `app/api/letters/[id]/pdf/route.ts`
  - `app/api/letters/[id]/send-email/route.ts`
  - `app/api/letters/[id]/audit/route.ts`

- Auth / profile / admin:
  - `app/api/create-profile/route.ts`
  - `app/api/admin-auth/login/route.ts` – admin login handler
  - `app/api/admin/super-user/route.ts` – toggle subscriber `is_super_user` flag / list super users

- Stripe:
  - `app/api/create-checkout/route.ts`
  - `app/api/verify-payment/route.ts`

### Libraries

- Supabase:
  - `lib/supabase/server.ts` – server-side client
  - `lib/supabase/client.ts` – client-side client
  - `lib/supabase/middleware.ts` – session + role-aware middleware

- Auth:
  - `lib/auth/get-user.ts` – fetches Supabase session + profile
  - `lib/auth/admin-session.ts` – **separate secure admin session** (cookie-based)

- Types:
  - `lib/database.types.ts` – TS types for `Profile`, `Letter`, `Subscription`, `Commission`, etc.

### Components

- Core layout:
  - `components/dashboard-layout.tsx`

- Letters:
  - `components/review-letter-modal.tsx` – admin review & AI improvement UI
  - `components/review-status-modal.tsx` – subscriber review status timeline
  - `components/letter-actions.tsx` – PDF / email actions

- Subscription / Stripe:
  - `components/subscription-card.tsx`
  - `components/subscription-modal.tsx`
  - `components/payment-verifier.tsx`

- UI:
  - `components/ui/*` – shadcn components (Button, Card, Badge, Skeleton, etc.)

### Database & Migrations

- Primary schema & RLS:
  - `supabase/migrations/*.sql`
  - `COMPLETE_MIGRATION.sql` – reference snapshot (do **not** re-run)

- Important tables:
  - `profiles` – id, email, full_name, `role` (`subscriber` | `employee` | `admin`), `is_super_user`, etc.
  - `letters` – letter lifecycle
  - `letter_audit_trail` – review history
  - `subscriptions` – plan, status, letters remaining
  - `employee_coupons`, `coupon_usage`
  - `commissions`
  - `security_audit_log`, `security_config`

- Important functions:
  - `check_letter_allowance(u_id)` – decides if user can generate a letter (`has_allowance`, `remaining`, `plan_name`, `is_super`)
  - `log_letter_audit(...)` – append audit entries
  - various RLS policies for `profiles`, `letters`, `coupon_usage`, etc.

---

## 3) Roles & Authorization

### Roles in `profiles.role`

- `'subscriber'`
  - Normal end-user
  - Access:
    - `/dashboard`
    - `/dashboard/letters`, `/dashboard/letters/new`, `/dashboard/letters/[id]`
    - `/dashboard/subscription`

- `'employee'`
  - Employee / affiliate
  - Access:
    - `/dashboard` → redirected to `/dashboard/commissions`
    - `/dashboard/commissions`
    - `/dashboard/coupons`
  - **Cannot see any letters data** (no direct access to `letters`).

- `'admin'`
  - **Exactly one admin user in the entire system**
  - Created via script: `scripts/create-admin-user.ts`
  - Logs in via: `/secure-admin-gateway/login`
  - Access:
    - `/secure-admin-gateway/dashboard` and its child routes
    - Admin-only APIs (e.g. `/api/admin/super-user`)

### Single Admin Rule

- There is **one** admin row in `profiles` (the seeded admin).
- **Do not**:
  - Create UI to promote users to `role = 'admin'`.
  - Allow signup as admin.
  - Create "super admin" / "super user admin" tiers.

### Understanding `is_super_user` (IMPORTANT)

- `profiles.is_super_user` **is NOT an admin role**. It is a **business flag** used for:
  - Unlimited letter allowances (bypasses subscription checks in `check_letter_allowance`)
  - VIP/internal user privileges
  - Displayed in `app/dashboard/subscription/page.tsx` as "Super User Status"
  - **Does NOT grant admin portal access**
  - **Does NOT grant elevated permissions**

**Authorization Examples:**

```typescript
// ✅ CORRECT: Check for admin authorization
const { data: profile } = await supabase
  .from('profiles')
  .select('role')
  .eq('id', userId)
  .single()

if (profile.role !== 'admin') {
  return NextResponse.json({ error: 'Unauthorized' }, { status: 403 })
}

// ❌ WRONG: Using is_super_user for authorization
if (!profile.is_super_user) {  // Never do this for admin checks
  return NextResponse.json({ error: 'Unauthorized' }, { status: 403 })
}

// ✅ CORRECT: Using is_super_user for business logic
const allowance = await supabase.rpc('check_letter_allowance', { u_id: userId })
// Function internally checks is_super_user to grant unlimited letters
```

**Copilot must never treat `is_super_user` as an authorization role. All admin auth checks must use `role = 'admin'` only.**

---

## 4) Routing, Middleware & Sessions

### Middleware (`lib/supabase/middleware.ts` + `middleware.ts`)

- The root `middleware.ts` calls `updateSession(request)` from `lib/supabase/middleware.ts`.
- `updateSession` is responsible for:
  - Initializing Supabase SSR client.
  - Syncing auth cookies.
  - Fetching the user + role (from `profiles`).
  - Applying role-based routing and protection.

Key behaviors (Copilot must respect/extend):

1. **Admin Portal Protection**

   ```ts
   const adminPortalRoute = process.env.ADMIN_PORTAL_ROUTE || 'secure-admin-gateway'

   if (pathname.startsWith(`/${adminPortalRoute}`)) {
     // `/secure-admin-gateway/login` is public
     // All other routes must have a valid admin session cookie
   }
   ```

   - Uses `verifyAdminSessionFromRequest(request)` from `lib/auth/admin-session.ts`.
   - If no valid admin session → redirect to `/secure-admin-gateway/login`.

2. **Block Legacy Admin Routes**

   ```ts
   if (pathname.startsWith('/dashboard/admin')) {
     // Always redirect to /dashboard
   }
   ```

   - Do not add new code under `/dashboard/admin/**`.
     All admin work lives under `/secure-admin-gateway/*`.

3. **Dashboard Protection**

   - If `!user` and `pathname.startsWith('/dashboard')` → redirect to `/auth/login`.
   - When at `/dashboard`, redirect based on `userRole`:
     - `admin` → now effectively goes through admin portal flows
     - `employee` → `/dashboard/commissions`
     - `subscriber` → stays on `/dashboard`

### Admin Session (`lib/auth/admin-session.ts`)

- Separate from Supabase auth.
- Uses cookie `admin_session` with:
  - `userId`
  - `email`
  - `loginTime`
  - `lastActivity`

- Login flow:
  - `app/secure-admin-gateway/login/page.tsx` POSTs to:
    - `/api/admin-auth/login`
  - `/api/admin-auth/login`:
    - Validates **email/password + portal key**.
    - Uses `verifyAdminCredentials` and `createAdminSession`.
    - Credentials & portal key are from env variables.

- In admin-only pages under `/secure-admin-gateway/dashboard/**`:
  - Check with `isAdminAuthenticated()` and/or rely on middleware guard.

**When adding or changing admin-only pages, enforce both:**

1. Path is under `/secure-admin-gateway/...`
2. Protected by admin session (middleware) and `role = 'admin'` in Supabase.

---

## 5) Letter Lifecycle & Status Flow

Letter statuses are defined in the `letter_status` enum and in `lib/database.types.ts`:

```ts
export type LetterStatus =
  | 'draft'
  | 'generating'
  | 'pending_review'
  | 'under_review'
  | 'approved'
  | 'completed'
  | 'rejected'
  | 'failed'
```

**Canonical flow:**

```text
draft → generating → pending_review → under_review → approved/rejected → completed/failed
```

Where:

- `draft`
  - User has started but not submitted letter for generation (may be implicit).

- `generating`
  - `/api/generate-letter` has created a record and is calling AI.

- `pending_review`
  - AI draft saved; waiting for admin review.

- `under_review`
  - Admin has opened the letter (see `start-review` API).

- `approved`
  - Admin approved final content.

- `rejected`
  - Admin rejected with a reason.

- `completed`
  - Fully processed: approved draft delivered (PDF/email).

- `failed`
  - AI generation or processing error.

**Audit Trail**

- Use `letter_audit_trail` and `log_letter_audit` Postgres function for:
  - status changes
  - approvals / rejections
  - failures

---

## 6) AI Integration – OpenAI via Vercel AI SDK

### Current Implementation

The application uses **OpenAI GPT-4 Turbo** via the **Vercel AI SDK** for all AI-powered features.

**Key Files:**

1. `app/api/generate-letter/route.ts` - Letter generation
2. `app/api/letters/[id]/improve/route.ts` - Letter improvement

### Architecture Overview

```
Client → Next.js API Route → Vercel AI SDK → OpenAI GPT-4 → Response
```

**Benefits of this approach:**
- ✅ Simple, single-codebase architecture
- ✅ Type-safe end-to-end
- ✅ Excellent developer experience with Vercel AI SDK
- ✅ Built-in streaming support
- ✅ Faster cold starts (no extra network hop)
- ✅ Single deployment pipeline
- ✅ Easier debugging and monitoring

### Standard AI Pattern

All AI calls should follow this pattern:

```typescript
import { openai } from "@ai-sdk/openai"
import { generateText } from "ai"

// In your API route
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    // 1. Auth check
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    // 2. Validate API key is configured
    if (!process.env.OPENAI_API_KEY) {
      console.error("[AI] Missing OPENAI_API_KEY")
      return NextResponse.json({ error: "Server configuration error" }, { status: 500 })
    }

    // 3. Build your prompt
    const prompt = buildPrompt(/* your params */)

    // 4. Call OpenAI via Vercel AI SDK
    const { text: generatedContent } = await generateText({
      model: openai("gpt-4-turbo"),
      system: "You are a professional legal attorney drafting formal legal letters...",
      prompt,
      temperature: 0.7,
      maxTokens: 2048,
    })

    // 5. Validate response
    if (!generatedContent) {
      throw new Error("AI returned empty content")
    }

    // 6. Return result
    return NextResponse.json({ content: generatedContent })

  } catch (error: any) {
    console.error("[AI] Generation error:", error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}
```

### Letter Generation Pattern

Example from `app/api/generate-letter/route.ts`:

```typescript
import { openai } from "@ai-sdk/openai"
import { generateText } from "ai"

// Create letter record with 'generating' status
const { data: newLetter } = await supabase
  .from("letters")
  .insert({
    user_id: user.id,
    letter_type: letterType,
    status: "generating",
    intake_data: intakeData
  })
  .select()
  .single()

try {
  // Generate letter using AI
  const { text: generatedContent } = await generateText({
    model: openai("gpt-4-turbo"),
    system: "You are a professional legal attorney drafting formal legal letters. Always produce professional, legally sound content with proper formatting.",
    prompt: buildPrompt(letterType, intakeData),
    temperature: 0.7,
    maxTokens: 2048,
  })

  // Update letter with generated content
  await supabase
    .from("letters")
    .update({
      ai_draft_content: generatedContent,
      status: "pending_review"
    })
    .eq("id", newLetter.id)

  // Log audit trail
  await supabase.rpc('log_letter_audit', {
    p_letter_id: newLetter.id,
    p_action: 'created',
    p_old_status: 'generating',
    p_new_status: 'pending_review',
    p_notes: 'Letter generated successfully by AI'
  })

  return NextResponse.json({
    success: true,
    letterId: newLetter.id,
    aiDraft: generatedContent
  })

} catch (error) {
  // Mark as failed on error
  await supabase
    .from("letters")
    .update({ status: "failed" })
    .eq("id", newLetter.id)

  throw error
}
```

### Letter Improvement Pattern

Example from `app/api/letters/[id]/improve/route.ts`:

```typescript
import { openai } from "@ai-sdk/openai"
import { generateText } from "ai"

// Verify admin authentication
const authError = await requireAdminAuth()
if (authError) return authError

const { content, instruction } = await request.json()

// Build improvement prompt
const prompt = `
Current letter content:
${content}

Improvement instruction:
${instruction}

Please improve the letter according to the instruction while maintaining professional legal tone and formatting.
`

// Call OpenAI for improvement
const { text: improvedContent } = await generateText({
  model: openai("gpt-4-turbo"),
  system: "You are a professional legal attorney improving formal legal letters. Always maintain professional legal tone and proper formatting.",
  prompt,
  temperature: 0.7,
  maxTokens: 2048,
})

return NextResponse.json({ improvedContent })
```

### Prompt Engineering Best Practices

1. **System Prompts**: Define the AI's role clearly
   ```typescript
   system: "You are a professional legal attorney drafting formal legal letters..."
   ```

2. **User Prompts**: Be specific with requirements
   ```typescript
   prompt: `Draft a ${letterType} letter with these requirements:
   - Professional legal tone
   - 300-500 words
   - Include proper formatting
   - Clear demands with deadlines`
   ```

3. **Temperature**: Use 0.7 for balanced creativity and consistency

4. **Max Tokens**: Set to 2048 for letter content (adjust as needed)

### Error Handling

Always wrap AI calls in try-catch and handle failures gracefully:

```typescript
try {
  const { text } = await generateText({ /* config */ })

  if (!text) {
    throw new Error("AI returned empty content")
  }

  // Process success...

} catch (error: any) {
  console.error("[AI] Generation failed:", error)

  // Update database status to 'failed'
  await supabase
    .from("letters")
    .update({ status: "failed" })
    .eq("id", letterId)

  // Log audit trail
  await supabase.rpc('log_letter_audit', {
    p_letter_id: letterId,
    p_action: 'generation_failed',
    p_notes: error.message
  })

  return NextResponse.json(
    { error: "AI generation failed" },
    { status: 500 }
  )
}
```

### Rules

- ✅ **DO** use Vercel AI SDK (`@ai-sdk/openai` and `ai` packages)
- ✅ **DO** use `gpt-4-turbo` model for legal content
- ✅ **DO** validate `OPENAI_API_KEY` is present before calling AI
- ✅ **DO** handle AI errors gracefully with proper status updates
- ✅ **DO** log all AI operations for debugging
- ❌ **DON'T** call OpenAI from client-side code
- ❌ **DON'T** expose `OPENAI_API_KEY` in client-accessible code
- ❌ **DON'T** use raw `fetch` to OpenAI - always use Vercel AI SDK
- ❌ **DON'T** skip error handling for AI calls

---

## 7) Subscriber Flow – Letter Generation, Free Trial, Subscription

### New Letter Flow

Files:

- `app/dashboard/letters/new/page.tsx`
- `app/api/generate-letter/route.ts`
- `FREE_TRIAL_IMPLEMENTATION.md`

Behavior:

1. User fills out intake form:
   - Sender info
   - Recipient info
   - Issue description
   - Desired outcome
   - Letter type (`LETTER_TYPES` list)

2. On submit, client calls:

   ```ts
   const response = await fetch("/api/generate-letter", { ... })
   const { letterId, aiDraft, isFreeTrial } = await response.json()
   ```

3. After response:
   - Pushes to `/dashboard/letters/[id]?submitted=1`.
   - `ReviewStatusModal` handles the "Request received → Under attorney review → Posted to My Letters" timeline.

### Free Trial

- First letter is **free**:
  - `generate-letter` checks how many letters user has generated.
  - If zero → allow without subscription, set `isFreeTrial = true`.
  - Subsequent letters:
    - Require active subscription with remaining credits.
    - If missing, return `{ needsSubscription: true }` and **HTTP 403/400**, and frontend pushes user to `/dashboard/subscription`.

### Subscription & Letter Allowances

Relevant files:

- `app/dashboard/subscription/page.tsx`
- `app/api/create-checkout/route.ts`
- `app/api/verify-payment/route.ts`
- Migrations:
  - `005_letter_allowance_system.sql`
  - `009_add_missing_subscription_fields.sql`
  - `010_add_missing_functions.sql`
- `DATABASE_FUNCTIONS.md`

Plans (as per business logic):

- One-time: 1 letter
- Monthly / yearly equivalents with 4 / 8 letters (see migrations and docs)

**Function `check_letter_allowance(u_id)`**:

- Returns `has_allowance`, `remaining`, `plan_name`, `is_super`.
- Used server-side to decide whether a subscriber can generate another letter.

**Key expectations for Copilot:**

- Do not change the meaning of `credits_remaining`, `remaining_letters`, or `plan_type`.
- When adding new server logic around letter creation, reuse `check_letter_allowance` instead of duplicating queries.
- Respect `is_super` / `is_super_user` as "unlimited access" for subscribers, **not** as an admin role.

---

## 8) Employee Coupons & Commissions

### Employee Coupon System

**Tables:**

- `employee_coupons` – coupon codes owned by employees
- `coupon_usage` – tracking who used which coupon
- `commissions` – earnings from coupon usage

**Auto-Generation:**

- Trigger: When new employee profile created
- Format: `EMP-XXXXXX` (6 character hash)
- Discount: 20%
- Auto-active: `is_active = true`

**Commission Structure:**

- Commission rate: 5% of purchase amount
- Points: 1 point per coupon use
- Status: `pending` → `paid`

**Employee Access:**

- Dashboard routes:
  - `/dashboard/coupons` – view and manage their coupon codes
  - `/dashboard/commissions` – view earnings and usage stats
- Cannot access letters data (RLS enforced)

**RLS Policies:**

- Employees can only see their own coupons
- Employees can only see commissions from their coupons
- Admin can see all coupons and commissions

---

## 9) TypeScript Best Practices

- Use strict TypeScript
- Define proper types for all data
- Use existing types from `lib/database.types.ts`
- Never use `any` without justification
- Prefer interfaces for object shapes
- Use type unions for status fields

**Example:**
```typescript
import { Database } from '@/lib/database.types'

type Profile = Database['public']['Tables']['profiles']['Row']
type LetterStatus = Database['public']['Enums']['letter_status']
```

---

## 10) Component Patterns

- Use existing shadcn/ui components from `components/ui/`
- Follow existing component patterns in the codebase
- Keep components modular and reusable
- Use client components (`'use client'`) only when needed for interactivity
- Server components by default for better performance
- Properly type component props

**Example:**
```typescript
interface LetterCardProps {
  letter: Letter
  onView?: (id: string) => void
}

export function LetterCard({ letter, onView }: LetterCardProps) {
  // Implementation
}
```

---

## 11) API Route Conventions

- Use Next.js App Router conventions (`route.ts` files)
- Implement proper error handling
- Return consistent JSON responses
- **Always check authentication first**
- Validate input data
- Use appropriate HTTP status codes

**Standard Pattern:**
```typescript
import { createClient } from "@/lib/supabase/server"
import { NextResponse } from "next/server"

export async function POST(request: Request) {
  try {
    // 1. Auth check
    const supabase = await createClient()
    const { data: { user }, error } = await supabase.auth.getUser()
    if (error || !user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    // 2. Parse and validate input
    const body = await request.json()
    // ... validation

    // 3. Business logic
    // ...

    // 4. Success response
    return NextResponse.json({ success: true, data: result })

  } catch (error) {
    console.error('API Error:', error)
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    )
  }
}
```

---

## 12) Security Best Practices

### Row Level Security (RLS)

- Always enable RLS on tables
- Use `auth.uid()` for user-specific policies
- Create separate policies for each operation (SELECT, INSERT, UPDATE, DELETE)
- Use helper function `get_user_role()` for role checks

**Example Policy:**

```sql
-- Subscribers can only see their own letters
CREATE POLICY "subscribers_view_own_letters"
ON letters FOR SELECT
TO authenticated
USING (
  user_id = auth.uid() AND
  get_user_role(auth.uid()) = 'subscriber'
);
```

### Environment Variables

Required in `.env.local`:
- `NEXT_PUBLIC_SUPABASE_URL`
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- `SERVICE_ROLE_KEY`
- `OPENAI_API_KEY` (for Vercel AI SDK)
- `STRIPE_SECRET_KEY`
- `NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY`
- `ADMIN_EMAIL`
- `ADMIN_PASSWORD`
- `ADMIN_PORTAL_KEY`

### Audit Trail

Always log important actions to `letter_audit_trail`:
```typescript
await supabase.rpc('log_letter_audit', {
  p_letter_id: letterId,
  p_action: 'approved',
  p_old_status: 'pending_review',
  p_new_status: 'approved',
  p_notes: 'Letter approved by admin'
})
```

### Input Validation

- Validate all user input
- Sanitize data before database operations
- Use Zod or similar for schema validation
- Never trust client-side data

---

## 13) Development Environment

This is a GitHub Codespaces environment with:
- Node.js 18+
- pnpm package manager
- PostgreSQL client tools
- Supabase CLI
- Python 3 (for Jupyter notebooks)
- Go, LLDB debugger support

**Always respect the existing environment configuration and don't make assumptions about paths or tool availability.**

**Common Commands:**

```bash
# Install dependencies
pnpm install

# Run development server
pnpm dev

# Run Supabase locally
supabase start

# Create new migration
supabase migration new <name>

# Deploy Edge Functions
supabase functions deploy <function-name>
```

---

## 14) WORKING WITH THIS CODEBASE: EXTENSION, NOT RECONSTRUCTION

**The #1 rule: This is NOT a greenfield project.**

### What "Extension" Means

✅ **DO THIS:**
- Add new API endpoints in existing `app/api/` structure
- Create new components in `components/` following existing patterns
- Add new pages under existing route groups (`/dashboard/*`, `/secure-admin-gateway/*`)
- Extend database schema with NEW migrations in `supabase/migrations/`
- Wire up incomplete features (e.g., missing API calls)
- Add validation and error handling to existing functions
- Migrate Gemini → OpenAI in the two specified files

❌ **DO NOT DO THIS:**
- Create a new `/src` folder and move files there
- Redesign the routing from `/app` to something else
- Replace `components/ui/*` with a different UI library
- Drop and recreate existing database tables
- Rewrite working features "to make them better"
- Create `/app/admin` routes when `/secure-admin-gateway` exists
- Add new admin roles when the requirement is "single admin"

### When You See Incomplete Code

If you find:
- Missing error handling → **Add it to the existing function**
- Hardcoded values → **Extract to constants in existing files**
- TODO comments → **Implement the TODO in place**
- Unused functions → **Remove or wire them up**

Do NOT:
- Move the file to a "better" location
- Refactor the entire module
- Introduce new patterns that conflict with existing code

### Pattern Matching

Before writing new code:
1. **Search** for similar existing functionality
2. **Copy** the patterns you find (imports, error handling, typing)
3. **Extend** with your specific logic
4. **Stay consistent** with the rest of the file

Example: If every other API route uses `createClient()` from `@/lib/supabase/server`, your new route must too.

### File Organization

Existing structure you must respect:

```
app/
  api/              ← Server-side API routes
  auth/             ← Public auth pages
  dashboard/        ← Subscriber/employee areas
  secure-admin-gateway/  ← Admin-only area
components/         ← React components
  ui/               ← shadcn/ui primitives (DO NOT replace)
lib/
  auth/             ← Auth helpers
  supabase/         ← Supabase clients & middleware
  database.types.ts ← Generated types (DO NOT hand-edit)
supabase/migrations/ ← Database migrations (append only)
```

**If you need a new file, put it in the appropriate existing folder.**

### AI Integration Architecture

**Current Implementation:**

- ✅ Using OpenAI GPT-4 Turbo via Vercel AI SDK
- ✅ AI calls in Next.js API routes (server-side only)
- ✅ Type-safe, excellent DX, production-ready

**Key Files:**

- `app/api/generate-letter/route.ts` - Letter generation with OpenAI
- `app/api/letters/[id]/improve/route.ts` - Letter improvement with OpenAI

**Pattern to Follow:**

```typescript
import { openai } from "@ai-sdk/openai"
import { generateText } from "ai"

const { text } = await generateText({
  model: openai("gpt-4-turbo"),
  system: "Your system prompt...",
  prompt: "Your user prompt...",
  temperature: 0.7,
  maxTokens: 2048
})
```

**When adding new AI features:**

1. Use Vercel AI SDK (never raw fetch to OpenAI)
2. Always check `OPENAI_API_KEY` is configured
3. Use `gpt-4-turbo` model for legal content
4. Implement proper error handling
5. Log operations for debugging

### Code Quality Standards

- Match existing code style (indentation, naming, etc.)
- Add comments only where logic isn't self-evident
- Don't add docstrings to functions you didn't create
- Keep solutions simple and focused on the requirement
- Only add error handling for realistic failure scenarios
- Trust framework guarantees (Next.js, Supabase, etc.)

---

## Summary: Key Principles

1. **Extend, never reconstruct** – Work within existing architecture
2. **Single admin only** – Never create multiple admin users or roles
3. **`is_super_user` is business logic, not authorization** – Use `role = 'admin'` for auth
4. **AI via Vercel AI SDK** – Use `@ai-sdk/openai` in Next.js API routes only
5. **Pattern matching** – Find similar code and follow its patterns
6. **RLS on everything** – Enforce security at database level
7. **Audit trail** – Log all important actions
8. **Validate input** – Never trust client data
9. **Use GPT-4 Turbo** – For all legal content generation
10. **Keep it simple** – Don't over-engineer solutions
